from dotenv import load_dotenv
from datetime import timedelta
import chromadb
import sqlite3
import hashlib
import os

load_dotenv()

REPORTS_DIR = os.getenv("REPORTS_DIR")
DB_PATH = os.getenv("DB_PATH")
DB_NAME = os.getenv("DB_NAME")

CLIENT = chromadb.PersistentClient(path=DB_PATH)
COLLECTION = CLIENT.get_or_create_collection(name="questions")

def stable_id(date: str, time: str, question: str) -> str:
    q_hash = hashlib.md5(question.encode("utf-8")).hexdigest()
    return f"{date}_{time}_{q_hash}"

def save_report(report_text, date, folder=REPORTS_DIR):
    """Save the daily report as a markdown file in the reports folder."""
    # Ensure reports folder exists
    os.makedirs(folder, exist_ok=True)

    # Normalize date string (e.g., '2025-09-16' → '2025-09-16.json')
    filename = f"{date}.json"

    # Full path
    filepath = os.path.join(folder, filename)

    with open(filepath, "w", encoding="utf-8") as f:
        f.write(report_text)

    print(f"✅ Report saved: {filepath}")

def init_db(db_path: str = DB_PATH + DB_NAME):
    """Create database schema if it does not exist."""
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()

    # Table for individual interactions
    cur.execute("""
    CREATE TABLE IF NOT EXISTS interactions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        date TEXT,
        question TEXT,
        answer TEXT,
        match_score REAL,
        time TEXT,
        embedding BLOB
    )
    """)

    # Unique index to prevent duplicate questions at the same date & time
    cur.execute("""
    CREATE UNIQUE INDEX IF NOT EXISTS idx_interactions_unique
    ON interactions(date, time, question)
    """)

    # Regular indexes for faster queries
    cur.execute("CREATE INDEX IF NOT EXISTS idx_interactions_date ON interactions(date)")
    cur.execute("CREATE INDEX IF NOT EXISTS idx_interactions_match_score ON interactions(match_score)")

    # Table for daily reports
    cur.execute("""
    CREATE TABLE IF NOT EXISTS daily_reports (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        date TEXT UNIQUE,
        n_logs INTEGER,
        average_match REAL,
        complete_misses INTEGER,
        complete_misses_rate REAL,
        report_text TEXT
    )
    """)

    # Table for weekly reports
    cur.execute("""
    CREATE TABLE IF NOT EXISTS weekly_reports (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        date TEXT UNIQUE,
        n_logs INTEGER,
        average_match REAL,
        complete_misses INTEGER,
        complete_misses_rate REAL,
        report_text TEXT
    )""")

    # Table for monthly reports
    cur.execute("""
    CREATE TABLE IF NOT EXISTS monthly_reports (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        date TEXT UNIQUE,
        n_logs INTEGER,
        average_match REAL,
        complete_misses INTEGER,
        complete_misses_rate REAL,
        report_text TEXT
    )
    """)

    conn.commit()
    conn.close()

def update_db_interactions(data, db_path: str = DB_PATH + DB_NAME):
    """Insert interactions into both the relational and vector database."""
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()

    date = data["date"]
    for log in data["logs"]:
        Q = log["question"]
        A = log["answer"]
        S = float(log["match_score"].replace("%", ""))
        T = log["time"]
        E = log["embedding"]

        # 1️⃣ Relational DB
        try:
            cur.execute("""
                INSERT INTO interactions (date, question, answer, match_score, time, embedding)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (
                date,
                Q,
                A,
                S,
                T,
                E.tobytes()
            ))
        except sqlite3.IntegrityError:
            print(f"⚠️ Duplicate entry for question on {data['date']} at {log['time']}: {log['question'][:30]}... Skipping.")

        # 2️⃣ Vector DB
        COLLECTION.add(
            documents=[Q],
            metadatas=[{
                "answer": A,
                "match_score": S,
                "date": date,
                "time": T
            }],
            ids=[stable_id(date, T, Q)],
            embeddings=[E]
        )

    conn.commit()
    conn.close()
    print(f"✅ Stored {len(data['logs'])} questions in both Relational and Vector DB for {data['date']}")
    return

def update_db_reports(data, report_text, report_type="daily_reports", db_path: str = DB_PATH + DB_NAME):
    """
    Save the generated daily report into the Relational database.
    data is the dict from parse_email()
    report_text is the markdown string generated by the LLM
    report_type is one of "daily_reports", "weekly_reports", "monthly_reports"
    """
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()

    # Insert or replace the daily report
    cur.execute(f"""
        INSERT OR REPLACE INTO {report_type} (date, n_logs, average_match, complete_misses, complete_misses_rate, report_text)
        VALUES (?, ?, ?, ?, ?, ?)
    """, (
        data["date"],
        data["n_logs"],
        data["average_match"],
        data["complete_misses"],
        data["complete_misses_rate"],
        report_text
    ))

    conn.commit()
    conn.close()
    print(f"✅ Saved report and {data['n_logs']} interactions for {data['date']}")

def fetch_past_week_reports(today, db_path: str = DB_PATH + DB_NAME):
    """Fetch daily reports from the last 7 days."""
    one_week_ago = today - timedelta(days=7)

    conn = sqlite3.connect(db_path)
    cur = conn.cursor()

    # Assuming `date` is stored in ISO format 'YYYY-MM-DD'
    cur.execute("""
        SELECT * FROM daily_reports
        WHERE date BETWEEN ? AND ?
        ORDER BY date ASC
    """, (one_week_ago.isoformat(), today.isoformat()))

    reports = cur.fetchall()
    conn.close()
    return reports  # TODO return also the date and the week range...???

def fetch_past_month_reports(today, db_path: str = DB_PATH + DB_NAME):
    """Fetch weekly reports from the last calendar month."""
    first_day_this_month = today.replace(day=1)

    conn = sqlite3.connect(db_path)
    cur = conn.cursor()

    cur.execute("""
        SELECT * FROM weekly_reports
        WHERE date BETWEEN ? AND ?
        ORDER BY date ASC
    """, (first_day_this_month.isoformat(), today.isoformat()))

    reports = cur.fetchall()
    conn.close()
    return reports
